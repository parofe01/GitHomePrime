<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Spotlight Phong Shader</title>
  <style>
    body { font-family: serif; }
    h1 { margin: 10px 0 12px 0; font-size: 34px; font-weight: 700; }
    .wrap { width: 600px; position: relative; }
    canvas { border: 1px solid black; width: 600px; height: 600px; display:block; background:#262626; }
    select {
      position: absolute;
      right: 8px;
      bottom: 8px;
      font-size: 13px;
      padding: 2px 6px;
      z-index: 10;
    }
    .controls { width: 600px; margin-top: 10px; }
    .controls label { display:block; margin-top: 6px; font-size: 14px; }
    .row { display:flex; align-items:center; gap:10px; }
    input[type="number"] { width: 80px; }
    input[type="range"] { width: 260px; }
    .val { font-size: 13px; }
  </style>

  <!-- Vertex: pasa posición (eye) + normal (eye) -->
  <script id="myVertexShader" type="x-shader/x-vertex">#version 300 es
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform mat3 normalMatrix;

    in vec3 VertexPosition;
    in vec3 VertexNormal;

    out vec3 vEC;   // posición en espacio ojo
    out vec3 vN;    // normal en espacio ojo

    void main() {
        vec4 ecPos = modelViewMatrix * vec4(VertexPosition, 1.0);
        vEC = ecPos.xyz;
        vN  = normalize(normalMatrix * VertexNormal);
        gl_Position = projectionMatrix * ecPos;
    }
  </script>

  <!-- Fragment: 5 modos -->
  <script id="myFragmentShader" type="x-shader/x-fragment">#version 300 es
    precision mediump float;

    in vec3 vEC;
    in vec3 vN;

    out vec4 fragmentColor;

    struct LightData {
        vec3 Position;   // coordenadas del ojo
        vec3 La;
        vec3 Ld;
        vec3 Ls;

        // Spotlight
        vec3 Direction;  // dirección del foco en coordenadas del ojo
        float Exponent;
        float Cutoff;    // grados
    };
    uniform LightData Light;

    struct MaterialData {
        vec3 Ka;
        vec3 Kd;
        vec3 Ks;
        float alpha;
    };
    uniform MaterialData Material;
    uniform MaterialData MaterialBack; // para two-sided

    struct FogData {
        float minDist;
        float maxDist;
        vec3 color;
    };
    uniform FogData Fog;

    // 0 Spotlight Phong
    // 1 Phong
    // 2 Toon
    // 3 Fog
    // 4 Two-sided
    uniform int uShaderMode;

    vec3 phong(MaterialData Mat, vec3 N, vec3 L, vec3 V) {
        vec3 ambient = Mat.Ka * Light.La;

        float NdotL = max(dot(N, L), 0.0);
        vec3 diffuse = NdotL * (Light.Ld * Mat.Kd);

        vec3 specular = vec3(0.0);
        if (NdotL > 0.0) {
            vec3 R = reflect(-L, N);
            float s = pow(max(dot(R, V), 0.0), Mat.alpha);
            specular = s * (Light.Ls * Mat.Ks);
        }

        return ambient + diffuse + specular;
    }

    // Spotlight Phong (según la teoría: factor solo afecta difusa+especular)
    vec3 spotlightPhong(MaterialData Mat, vec3 N, vec3 L, vec3 V, vec3 ec) {
        vec3 ambient = Mat.Ka * Light.La;

        float NdotL = dot(N, L);
        if (NdotL <= 0.0) return ambient;

        // Vector desde el punto hacia la luz (como L, pero lo recalculamos por claridad)
        vec3 S = normalize(Light.Position - ec);

        // Dirección del foco (en eye space)
        vec3 D = normalize(Light.Direction);

        // Ángulo de corte
        float cutoffDeg = clamp(Light.Cutoff, 0.0, 90.0);
        float cosCut = cos(radians(cutoffDeg));

        // cos del ángulo entre el eje del foco y el vector desde la luz al punto
        // (vector desde la luz al punto = -S)
        float spotCos = dot(normalize(-S), D);

        float spotFactor = 0.0;
        if (spotCos >= cosCut) {
            spotFactor = pow(max(spotCos, 0.0), max(Light.Exponent, 0.0));
        }

        // Phong base (difusa + especular)
        vec3 diffuse = max(dot(N, L), 0.0) * (Light.Ld * Mat.Kd);

        vec3 specular = vec3(0.0);
        vec3 R = reflect(-L, N);
        float s = pow(max(dot(R, V), 0.0), Mat.alpha);
        specular = s * (Light.Ls * Mat.Ks);

        return ambient + spotFactor * (diffuse + specular);
    }

    vec3 toon(MaterialData Mat, vec3 N, vec3 L) {
        vec3 ambient = Mat.Ka * Light.La;

        float NdotL = max(dot(N, L), 0.0);

        // niveles MUY marcados para que se note
        float levels = 4.0;
        float q = floor(NdotL * levels) / (levels - 1.0);

        vec3 diffuse = q * (Light.Ld * Mat.Kd);
        return ambient + diffuse;
    }

    vec3 applyFog(vec3 col, vec3 ec) {
        float d = length(ec);
        float f = (Fog.maxDist - d) / (Fog.maxDist - Fog.minDist);
        f = clamp(f, 0.0, 1.0);
        return mix(Fog.color, col, f);
    }

    void main() {
        vec3 N = normalize(vN);
        vec3 ec = vEC;

        // luz puntual
        vec3 L = normalize(Light.Position - ec);
        vec3 V = normalize(-ec);

        vec3 col = vec3(0.0);

        if (uShaderMode == 0) { // Spotlight Phong
            col = spotlightPhong(Material, N, L, V, ec);
        }
        else if (uShaderMode == 1) { // Phong
            col = phong(Material, N, L, V);
        }
        else if (uShaderMode == 2) { // Toon
            col = toon(Material, N, L);
        }
        else if (uShaderMode == 3) { // Fog (Phong + niebla)
            vec3 base = phong(Material, N, L, V);
            col = applyFog(base, ec);
        }
        else if (uShaderMode == 4) { // Two-sided
            if (gl_FrontFacing) {
                col = phong(Material, N, L, V);
            } else {
                // invertimos N para iluminar correctamente la cara trasera
                col = phong(MaterialBack, -N, L, V);
            }
        }

        fragmentColor = vec4(col, 1.0);
    }
  </script>
</head>

<body>
<h1 id="shaderTitle">Spotlight Phong Shader</h1>

<div class="wrap">
  <canvas id="myCanvas" width="600" height="600">
    Tu navegador no soporta HTML5
  </canvas>

  <!-- LISTA EXACTA COMO TU FOTO 1 -->
  <select id="shaderSelect">
    <option value="0" selected>Spotlight Phong Shader</option>
    <option value="1">Phong Shader</option>
    <option value="2">Toon Shader</option>
    <option value="3">Fog Shader</option>
    <option value="4">Two-sided Shader</option>
  </select>
</div>

<div class="controls">
  <label>Dirección de luz X</label>
  <input type="number" id="dirX" step="0.1" value="1">

  <label>Dirección de luz Y</label>
  <input type="number" id="dirY" step="0.1" value="1">

  <label>Dirección de luz Z</label>
  <input type="number" id="dirZ" step="0.1" value="1">

  <label>Exponente</label>
  <div class="row">
    <input type="range" id="expSlider" min="0" max="128" value="0">
    <span class="val">Value: <span id="expVal">0</span></span>
  </div>

  <label>Cutoff</label>
  <div class="row">
    <input type="range" id="cutoffSlider" min="0" max="100" value="100">
    <span class="val">Value: <span id="cutoffVal">100</span></span>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
<script src="phong_basic.js"></script>
</body>
</html>
