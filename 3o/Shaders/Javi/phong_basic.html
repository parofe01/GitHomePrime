<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Dibuja</title>
    <style type="text/css">
        canvas { border: 1px solid black; }
    </style>

    <script id="myVertexShader" type="x-shader/x-vertex">#version 300 es
    
    uniform mat4 modelViewMatrix; //matriz de transformacion del modelo
    uniform mat4 projectionMatrix; //matriz de proyeccion
    uniform mat3 normalMatrix; //matriz de transformacion de la normal

    in vec3 VertexPosition;
    in vec3 VertexNormal;

    out vec3 colorOut;

    //---------------Phong---------------------------
    struct LightData {
    vec3 Position; // Posición en coordenadas del ojo
    vec3 La;       // Luz ambiente
    vec3 Ld;       // Luz difusa
    vec3 Ls;       // Luz especular
    };
    uniform LightData Light;

    struct MaterialData {
        vec3 Ka;    // Componente ambiente del material
        vec3 Kd;    // Componente difusa del material
        vec3 Ks;    // Componente especular del material
        float alpha; // Brillo especular (shininess)
    };
    uniform MaterialData Material;

    // N, L y V se asumen normalizados
    vec3 phong(vec3 N, vec3 L, vec3 V) {
        vec3 ambient = Material.Ka * Light.La;
        vec3 diffuse = vec3(0.0);
        vec3 specular = vec3(0.0);

        float NdotL = dot(N, L);
        if (NdotL > 0.0) {
            vec3 R = reflect(-L, N);
            float RdotV_n = pow(max(0.0, dot(R, V)), Material.alpha);
            diffuse  = NdotL * (Light.Ld * Material.Kd);
            specular = RdotV_n * (Light.Ls * Material.Ks);
        }

        return (ambient + diffuse + specular);
    }
    //-----------------------------------------------

    void main() {
        // Normal transformada
        vec3 N = normalize(normalMatrix * VertexNormal);

        // Posición en espacio ojo
        vec4 ecPosition = modelViewMatrix * vec4(VertexPosition, 1.0);
        vec3 ec = vec3(ecPosition);

        // Dirección hacia la luz
        vec3 L = normalize(Light.Position - ec);

        // Dirección hacia la cámara (ojo)
        vec3 V = normalize(-ec);

        // Calcular color con Phong
        colorOut = phong(N, L, V);

        // Posición final en clip space
        gl_Position = projectionMatrix * ecPosition;
    }

    </script>

    <script id="myFragmentShader" type="x-shader/x-fragment">#version 300 es
    precision mediump float;
    in vec3 colorOut;
    out vec4 fragmentColor;

    void main() {
        fragmentColor = vec4(colorOut, 1.0);
    }


    </script>

</head>
<body>
    <canvas id="myCanvas" width="600" height="600">
        Tu navegador no soporta HTML5
    </canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
    <script src="phong_basic.js"></script>
</body>
</html>
